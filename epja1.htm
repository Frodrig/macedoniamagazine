<HTML>
<BASE TARGET="TEXTO">
<BODY BGCOLOR="#FFFFFF">
<center><TABLE BORDER=0 align = center WIDTH="*" HEIGHT="*" BGCOLOR="#009933" cellspacing=0 CELLPADDING=2>
<TD>
<TABLE BORDER=0 WIDTH="*" align = center HEIGHT="*" BGCOLOR="#FDEDBD" cellspacing=0 CELLPADDING=2>
<TR>
<TD>
<DIV align="center">
<FONT COLOR="#009933" size=7 face="arial"><B>D</B></font><FONT color="#000000" size=7 face="arial"><B>esarrollo de Videojuegos</B></FONT>
</DIV>
</TD>
</TR>
</TABLE></TD>
</TABLE></center>
<br>

<HR>		  







<TABLE align = left BORDER=0 WIDTH="*" HEIGHT="*" BGCOLOR="#009933" cellspacing=0 CELLPADDING=2>

<TD>

<TABLE align = left BORDER=0 WIDTH="*"  HEIGHT="*" BGCOLOR="#FDEDBD" cellspacing=0 CELLPADDING=2>

<TR>

<TD>

<DIV align="left">

<FONT COLOR="#009933" size=3 face="arial"><B>E</B></font><FONT color="#000000" size=2 face="arial"><B>ntornos 2D</B></FONT></a>
</DIV>

</TD>

</TR>

</TABLE></TD>

</TABLE>

<br><br>



<img SRC="g_misc/69.gif" align=right>

<P align=right>

<FONT color="#cc0000" size=2 face="arial">

<b>A</b></font><FONT color="#000000" size=2 face="arial"><b>rtículo realizado por<br>

<A HREF="mailto:i9808685@petra.euitio.uniovi.es">Fernando Rodríguez</A>

</b></FONT>

<br><br>

<FONT size=2 color="#000000" face="Arial"><br><br><br>

<H3>

Introducción a la técnica de los "tiles".

</H3>

<font size=2 face=arial>

<P ALIGN=JUSTIFY><FONT FACE="Arial"><FONT FACE="Arial" SIZE=2>
<P ALIGN="JUSTIFY">En este art&iacute;culo vamos a echar un vistazo a una de las t&eacute;cnicas m&aacute;s interesantes para la construcci&oacute;n de escenarios; la t&eacute;cnica de los &quot;tiles&quot; &oacute; &quot;baldosas&quot;. Seguro que muchos de vosotros os habr&eacute;is preguntado, al ver un juego t&iacute;pico de estrategia o aventura en 2D, c&oacute;mo poder almacenar escenarios de tan grandes proporciones sin pedir, como requerimientos m&iacute;nimos, cantidades ingentes de memoria RAM. La t&eacute;cnica de los &quot;tiles&quot; permite construir escenarios utilizando peque&ntilde;as porciones de distintas texturas que, poni&eacute;ndolas de forma adyacente (unas al lado de otras), encajan a la perfecci&oacute;n dando la sensaci&oacute;n de que todo lo que vemos es un gr&aacute;fico de una sola pieza. As&iacute; pues, los &quot;tiles&quot; permiten construir escenarios o mapas mediante la utilizaci&oacute;n inteligente de peque&ntilde;as porciones gr&aacute;ficas que se identifican por sus diferentes texturas. As&iacute;, podemos crear un escenario de grandes proporciones que simule un prado mediante la uni&oacute;n de &quot;tiles&quot; que tengan la misma textura. En este caso, la textura deber&iacute;a de simular ese color propio de un terrero verde. La utilizaci&oacute;n de &quot;tiles&quot; ha sido muy provechosa para la creaci&oacute;n de escenarios en juegos de estrategia o aventuras "a vista de p&aacute;jaro" pues permiten a los programadores disponer de mapas fabricados a partir de matrices que toman diferentes valores dependiendo del &quot;tile&quot; que se representan en pantalla. </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Por otro lado, existen dos implementaciones principales para representar los &quot;tiles&quot;. La m&aacute;s b&aacute;sica, que es la que veremos aqu&iacute;, consiste en disponerlos de tal forma que simulen un escenario visto desde arriba. La otra, es la que implementa una vista isom&eacute;trica de tal forma que los &quot;tiles&quot; vienen a ser rombos que, una vez colocados de forma adyacente, crean una sensaci&oacute;n de profundidad 3D. He aqu&iacute; algunas muestras de juegos que utilizan estas t&eacute;cnicas.</P>
<P ALIGN="JUSTIFY"></P>

<CENTER><TABLE>
<TD><IMG SRC="jpg/tiles0a.jpg"></TD><TD><IMG SRC="jpg/tiles0b.jpg"></TD>
<TR>
<TD><FONT SIZE=1 FACE=ARIAL><CENTER>Dune 2</CENTER></FONT></TD>
<TD><FONT SIZE=1 FACE=ARIAL><CENTER>Sid Meier's Civilization</CENTER></FONT></TD>
<tr>
<TD><IMG SRC="jpg/tiles0c.jpg"></TD><TD><IMG SRC="jpg/tiles0d.jpg"></TD>
<TR>
<TD><FONT SIZE=1 FACE=ARIAL><CENTER>FallOut</CENTER></FONT></TD>
<TD><FONT SIZE=1 FACE=ARIAL><CENTER>Sid Meier's Civilization II</CENTER></FONT></TD>
</TABLE></CENTER>
<FONT SIZE=1 FACE=ARIAL><CENTER>Dune 2 y Sid Meier's Civilization utilizaron tiles con
perspectiva "a vista de pájaro". <br>FallOut y la segunda parte de Civilization, se pasaron a
perspectiva isométrica.</CENTER></FONT>

<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Para poder entender todo mejor, basar&eacute; mi explicaci&oacute;n en un antiguo desarrollo, llamado &quot;Maptool&quot;, para la construcci&oacute;n de escenarios. Ver&eacute;is, que alguno de los &quot;tiles&quot; han sido sacados del &quot;Civilization II&quot;. Esto es as&iacute; porque el set original del &quot;Maptool&quot; (que data de 1994), dejaba bastante que desear. Por otro lado, la aplicaci&oacute;n ha sufrido muchas variaciones para uso puramente personal (para realizar pruebas de programaci&oacute;n) por lo que la flexibilidad del programa es nula. .Su car&aacute;cter es, pues, did&aacute;ctico y puede servir de ayuda a todos aquellos que quieran crear una herramienta como el &quot;Maptool&quot; para sus propios proyectos o experimentos.</P>
<P ALIGN="JUSTIFY"></P>

<hr width=60%>
<CENTER>
<FONT size=2 color="#cc0000" face="Arial">
<b>Puedes conseguir el MapTool pulsando </b><A HREF="zip/maptool.zip"><B>aquí</B></a>
</CENTER>
<hr width=70%>

</FONT><h4><FONT FACE="Arial"><P>Una primera aproximaci&oacute;n al problema
</h4></FONT><FONT SIZE=2>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Vamos a realizar, ahora, una aproximaci&oacute;n al problema del dise&ntilde;o de las estructuras de datos e implementaciones necesarias para resolver la representaci&oacute;n del mapa a editar. Posteriormente, iremos m&aacute;s al grano.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Como se dijo al comienzo, un &quot;tile&quot; es una imagen gr&aacute;fica de muy peque&ntilde;as dimensiones (16x16 o 32x32 pixels). Obviamente, a medida que aumentemos la resoluci&oacute;n del juego, deberemos de trabajar con tama&ntilde;os m&aacute;s grandes para los &quot;tiles&quot;. Si al igual que hacemos con una baldosa al construir el suelo de una casa, unimos varios de esos &quot;tiles&quot; obtendremos un bloque capaz de representar un mapa mucho m&aacute;s grande en t&eacute;rminos de resoluci&oacute;n. Esto abre grandes posibilidades para ser utilizado en editores de escenarios pues no obliga a los creadores a trabajar, por ejemplo, con un bitmap de grandes dimensiones. Si tuvi&eacute;ramos que utilizar un bitmap que representara un mapa, necesitar&iacute;amos un bitmap de proporciones enormes y, por consiguiente, mucha cantidad de memoria para mantenerlo. Si el mapa fuera de dimensiones muy reducidas, es decir, de una resoluci&oacute;n igual o menor a la que se est&aacute; utilizando en pantalla, realmente no estar&iacute;amos utilizando un mapa, sino una &quot;imagen de fondo&quot;.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">La idea es, pues, utilizar una matriz (m&aacute;s adelante, analizaremos el uso de listas din&aacute;micas. Mientras tanto, vamos a suponer que el mapa est&aacute; construido sobre una matriz) de las dimensiones del mapa a representar. Cada coordenada del mapa dispondr&iacute;a de un valor num&eacute;rico que indicar&iacute;a qu&eacute; &quot;tile&quot; debe de cargarse en dicha zona. </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Imaginemos por un momento que el mapa representa un oc&eacute;ano. Bastar&aacute; con poner repetidamente el tile que tiene textura de oc&eacute;ano en pantalla, o lo que es lo mismo, inicializar el array o matriz con el valor num&eacute;rico que utilizamos para representar al &quot;tile&quot; agua. Cuando nos movamos por el mapa (o array), lo que haremos ser&aacute; leer el n&uacute;mero del tile que hay que poner, ir a una tabla que nos diga en qu&eacute; coordenada del buffer (supongo que la persona que est&eacute; leyendo este art&iacute;culo, tiene conocimientos m&iacute;nimos de programaci&oacute;n gr&aacute;fica) se encuentra el tile que representa el agua y, finalmente, dibujar ese &quot;tile&quot; en el mapa de edici&oacute;n. Esta t&eacute;cnica resulta muy poderosa si se dispone de un set de &quot;tiles&quot; preparado y bien texturizado tarea, &eacute;sta, que deber&iacute;a de ser cubierta por el grafista del grupo. Si no hay tal grafista, el programador siempre puede apa&ntilde;&aacute;rselas con gr&aacute;ficos rudimentarios pero que le sirvan para poder comenzar a trabajar en el &quot;engine&quot; basado en &quot;tiles&quot;. </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Una vez que hemos realizado una primera aproximaci&oacute;n a c&oacute;mo poder implementar un mapa basado en &quot;tiles&quot;, cabr&iacute;a profundizar un poco m&aacute;s en la idea pues, en el momento que vayamos a codificar, nos daremos cuenta de otros factores que existen en un mapa y cumplen unas condiciones peculiares. </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">A parte de la base o terreno sobre el que est&aacute; construido un mapa (por ejemplo, un &quot;tile&quot; que represente suelo verde), &eacute;ste tambi&eacute;n tiene otro factores que, por as&iacute; decirlo, van encima de lo que es la base. S&oacute;lo hace falta volver a pensar en una pradera. Sobre la pradera podr&iacute;a ir un r&iacute;o o existir una monta&ntilde;a. Si pensamos en un desierto, en medio de &eacute;ste pudiera existir un oasis, o un grupo de camellos, etc. A estos aspectos a representar en el mapa les vamos a denominar aspectos de forma pues contribuyen a &quot;modelar&quot; el set de &quot;tiles&quot; destinado a crear el terreno o la base del escenario (por ejemplo, una monta&ntilde;a que se a&ntilde;ade a un terreno rocoso). As&iacute; pues, el set de forma se a&ntilde;ade siempre encima del set de &quot;tiles&quot; base pero no lo destruye sino que se acopla a &eacute;l. Para hacer esto, como veremos m&aacute;s adelante, podremos utilizar varias t&eacute;cnica. Tenemos la opci&oacute;n de acudir a m&aacute;scaras o bien decantarnos por la utilizaci&oacute;n del color invisible. &quot;Maptool&quot; utiliza &eacute;sta &uacute;ltima t&eacute;cnica. Junto al set de &quot;tiles&quot; de forma, podemos pensar en otro llamado set de &quot;tiles&quot; objeto que lo que haga sea a&ntilde;adir un factor miscelaneo al mapa, es decir, que a&ntilde;ada aspectos que no tengan por qu&eacute; configurar el aspecto propio del terreno pero que s&iacute; ayuden a dar vivacidad al mundo que estamos creando. As&iacute; pues, en este set podr&iacute;an ir personas, animales, medios de transporte, etc.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">En conclusi&oacute;n, hemos visto que podemos utilizar un array o matriz para representar el mapa que estamos editando. Dicho array podr&iacute;a tener unas dimensiones de mxn casillas (en el caso de &quot;Maptool&quot;, los escenarios son de 64x64 casillas. Por supuesto, una herramienta bien dise&ntilde;ada deber&iacute;a de ofrecer amplia libertad para elegir las dimensiones del mapa). Tambi&eacute;n hemos visto que cada casilla o posici&oacute;n del array, puede quedar definida por tres valores de tres set distintos de &quot;tiles&quot;. A saber: </P>
<P ALIGN="JUSTIFY"></P>
<OL>

<LI>Set de Base.</LI>
<LI>Set de Forma.</LI>
<LI>Set de Objetos.</LI></OL>

<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Adem&aacute;s, el orden en que se dibujar&iacute;an en el mapa ser&iacute;a el mostrado arriba de tal forma que la parte m&aacute;s visible es la concerniente al set de objetos (imagin&eacute;monos la situaci&oacute;n. Pintamos un terreno verde, encima un r&iacute;o y, por &uacute;ltimo, una peque&ntilde;a barca con un pescador).</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Antes de abandonar esta aproximaci&oacute;n a la representaci&oacute;n de los &quot;tiles&quot;, comentar que el poco c&oacute;digo que se va a ense&ntilde;ar aqu&iacute; (la idea es que la persona que lea esto pueda hacerse una idea m&aacute;s o menos clara de c&oacute;mo hacer las cosas), va a ser en el C de toda la vida. Pero repito que, como apenas va a ver c&oacute;digo, con lo aqu&iacute; explicado se podr&aacute; crear el engine en cualquier lenguaje.</P>
<P ALIGN="JUSTIFY"></P>
</FONT><h4><FONT FACE="Arial">Representaci&oacute;n de los &quot;tiles&quot; en el &quot;Maptool&quot;.
</h4></FONT><FONT FACE="Arial" SIZE=2>
<P ALIGN="JUSTIFY">Los &quot;tiles&quot; del &quot;Maptool&quot;, se representan en un array de 64x64. Como dicho array tiene un gran tama&ntilde;o se reserva espacio, al comienzo del programa, para mantener dicho array. El array contiene, para cada posici&oacute;n, tres campos. Cada uno de los campos o variables est&aacute; destinado a mantener un &quot;tile&quot; que corresponde a una de las tres capas que existen: capa base, capa de forma y capa de objetos (este concepto se examinar&aacute; con mayor profundidad en el apartado siguiente <B>"El concepto de 'las tres capas' "</B>). Se puede examinar la estructura que define y mantiene el mapa de edici&oacute;n, a continuaci&oacute;n:</P>
<P ALIGN="JUSTIFY"></P>
</FONT>
<PRE>
<FONT FACE="Courier New" SIZE=3><b>typedef</B> <B>struct</B> mapaEdicion {
     <B>unsigned char</B> tileBase;
     <B>unsigned char</B> tileForma;
     <B>unsigned char</B> tileObjeto;
}; // Definici&oacute;n de los datos del mapa de edici&oacute;n.</PRE>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Los &quot;tiles&quot; se representan en el array como un tipo de datos <B>unsigned</B> <B>char</B>, es decir, no habr&aacute; ning&uacute;n set que tenga m&aacute;s de 256 &quot;tiles&quot; distintos.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">En cuanto a la representaci&oacute;n externa, los &quot;tiles&quot; se encuentran dibujados en un archivo .SCR (formato propio). Este archivo contiene una informaci&oacute;n, la de los &quot;tiles&quot;, que es continuamente utilizada. Una buena idea es mantenerlo en memoria pues, de lo contrario, los continuos acceso a disco terminar&iacute;an por exasperar a cualquiera. Tal y como hicimos con el mapa que contiene los &quot;tiles&quot;, el buffer que contiene la gr&aacute;ficos de los &quot;tiles&quot; es reservado nada m&aacute;s arrancar la aplicaci&oacute;n. Los &quot;tiles&quot; tienen un tama&ntilde;o de 32x32 pixels.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Antes de pasa a mostrar la imagen del archivo que contiene a los tiles, tenemos que tener constancia de un aspecto muy importante. Cuando nosotros dise&ntilde;amos (o encargamos dise&ntilde;ar) un set de &quot;tiles&quot; para el terreno, debemos de tener en cuenta que necesitaremos de una serie de &quot;tiles&quot; que nos proporcionen una transici&oacute;n de un tipo de terreno a otro. Para entender esto mejor, nada como un gr&aacute;fico explicativo: </P>
<P ALIGN="JUSTIFY"></P>
<CENTER><TABLE>
<TD><IMG SRC="jpg/tiles01a.jpg"></TD>
<TR>
<TD><FONT SIZE=1 FACE=ARIAL><CENTER>Sin transición</CENTER></FONT></TD>
<TR>
<TD><IMG SRC="jpg/tiles01b.jpg"></TD>
<TR>
<TD><FONT SIZE=1 FACE=ARIAL><CENTER>Con transición</CENTER></FONT></TD>

</TABLE></CENTER>

<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Como se puede observar, cuando no hay un &quot;tile&quot; especial que se encargue de proporcionar la transici&oacute;n entre diferentes tipos de terrenos, el resultado es que tenemos un mapa muy brusco y, por consiguiente, muy poco real. Sin embargo, si destinamos un &quot;tile&quot; especial a para cubrir tal objetivo, obtendremos un mapa mucho m&aacute;s coherente y menos tosco. El problema est&aacute; en ingeni&aacute;rnoslas para tener un n&uacute;mero de &quot;tiles&quot; peque&ntilde;o que se encargue de realizar todas las transiciones entre tipos de terreno. Fij&eacute;monos, ahora, en la figura siguiente que muestra 5 de los 12 tipos de transici&oacute;n, para los tipos de terreno &quot;agua&quot;, &quot;hierba&quot; y &quot;desierto&quot;:</P>
<P ALIGN="JUSTIFY"></P>
<CENTER><TABLE>
<TD><IMG SRC="gif/tiles02a.gif"></TD>
<TR>
<TD><IMG SRC="gif/tiles02b.gif"></TD>
<tr>
<TD><IMG SRC="gif/tiles02c.gif"></TD>
<TR>
</TABLE></CENTER>

<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Como se puede observar, todos los terrenos llevan el mismo tipo de transici&oacute;n. Si logr&aacute;ramos hacer una especie de &quot;molde&quot; sobre el que construir las diferentes transiciones utilizando los &quot;tiles&quot; de base, quiz&aacute;s podr&iacute;amos superar este problema. En el &quot;Maptool&quot;, el set de &quot;tiles&quot; base contiene 7 &quot;tiles&quot;, el set de forma 32 &quot;tiles&quot; y el set de &quot;tiles&quot; objeto 14. Como hemos explicado m&aacute;s atr&aacute;s, en el set de &quot;tiles&quot; deber&iacute;a de haber muchos m&aacute;s pues los &quot;tiles&quot; dedicados a simular el paso de un tipo de base a otra son 12 y si hay 7 bases distintas deber&iacute;amos de tener 12x7 = 84 &quot;tiles&quot;</FONT><FONT FACE="Courier New" SIZE=2>,</FONT><FONT FACE="Arial" SIZE=2> o lo que es lo mismo, un ingente gasto de memoria. Para solucionar el problema, lo que se hace es construir, en tiempo de ejecuci&oacute;n, los tiles de transici&oacute;n. Para ello, se usan unos moldes que se encargan de simular los 12 &quot;tiles&quot; que representan el cambio de una base de terreno a otra. Aqu&iacute; ofrecemos la idea, en el apartado <B>"&quot;tiles&quot; que se construyen en tiempo de ejecuci&oacute;n"</B> los explicamos m&aacute;s exhaustivamente.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">A continuaci&oacute;n se muestra el aspecto del archivo que contiene la informaci&oacute;n gr&aacute;fica de los distintos set de &quot;tiles&quot;:</P>
<P ALIGN="JUSTIFY"></P>
<center><img src="jpg/tiles03.jpg"></center>
<FONT SIZE=1 FACE=ARIAL><CENTER>Todos los tiles del Maptool.</CENTER></FONT>

<P ALIGN="JUSTIFY"></P>
</FONT><h4><FONT FACE="Arial">El concepto de "las tres capas".
</h4></FONT><FONT FACE="Arial" SIZE=2>
<P ALIGN="JUSTIFY">El concepto de las tres capas hace referencia al uso de los tres grupos de &quot;tiles&quot; con los que trabajamos, aunque podr&iacute;an ser muchos m&aacute;s. Estos set son:</P>
<P ALIGN="JUSTIFY"></P>
<OL>

<B><P ALIGN="JUSTIFY"><LI>Set de base</B>. Son los &quot;tiles&quot; que forman el terreno.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>Set de forma</B>. Son los &quot;tiles&quot; que completan el terreno, tales como r&iacute;os, paso de una estructura de base a otra, monta&ntilde;as, lagos, etc.</LI></P>
<B><P ALIGN="JUSTIFY"><LI>Set de objeto</B>. Son los &quot;tiles&quot; que incorporan animales, casas, barcos, etc.</LI></P></OL>
<center><img src="jpg/tiles04.jpg"></center>
<FONT SIZE=1 FACE=ARIAL><CENTER>Orden de dibujado de las capas.</CENTER></FONT>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Como vimos m&aacute;s arriba, la estructura o array que se encarga de almacenar los &quot;tiles&quot;, cuenta con tres campos en donde distinguir los &quot;tiles&quot; que vamos incorporando al mapa. Una de estas variables es la de base, otra la de forma y, por &uacute;ltimo, otra para el objeto. El editor trabaja con estos tres tipos distintos de set y cada una de las posiciones que editamos puede tener un tile de cada uno de los set. El tile que siempre es obligado que tenga el mapa es el que corresponde al set de &quot;tiles&quot; base. Por el contrario, no pasar&aacute; nada si falta el tile de forma o el de objeto. Bastar&aacute; con utilizar un c&oacute;digo que signifique &quot;no hay tile&quot; y, simplemente, no dibujaremos nada (&quot;Maptool&quot; utiliza el c&oacute;digo 0 para indicar que no hay &quot;tile&quot;) </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Para poder representar los &quot;tiles&quot; sobrepuestos sin que se machaque el dibujo, es decir, de tal forma que se dibuje s&oacute;lo el contorno de los &quot;tiles&quot; que pertenecen al set de forma u objeto, se utiliza la t&eacute;cnica que se vale de un determinado color de la paleta, conocido como color invisible (que suele ser el color 0 de la paleta), que nunca se imprime en pantalla. Esta t&eacute;cnica lo que hace es leer el gr&aacute;fico del &quot;tile&quot; que se debe de dibujar una posici&oacute;n del mapa recorriendo cada una de los pixels del mismo. Si el valor le&iacute;do o byte le&iacute;do (estamos trabajando con 256 colores luego cada pixel se representa con un byte) es distinto a 0, ese valor se llevar&aacute; a pantalla. Si, por el contrario el valor es 0, no se llevar&aacute; a pantalla. En ambos casos, despu&eacute;s de la comprobaci&oacute;n y del posible dibujo, aumentaremos la posici&oacute;n de lectura sobre el gr&aacute;fico del &quot;tile&quot;. Esta t&eacute;cnica es ampliamente utilizada para representar sprites o im&aacute;genes discontinuas. Obviamente, cuando digo &quot;se llevar&aacute; a pantalla&quot;, me refiero que a que se llevar&aacute; a un buffer sobre el que estaremos construyendo la imagen que luego s&iacute; que se volcar&aacute; a pantalla (repito que entiendo que la persona que lea esto tiene unos conocimientos elementales de la programaci&oacute;n gr&aacute;fica. Si no es as&iacute;, me remito a los art&iacute;culos sobre sprites publicados en este mismo n&uacute;mero de Macedonia).</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">A modo de ejemplo, si la imagen (sprite o tile) a representar es la siguiente:</P>
<P ALIGN="JUSTIFY"></P>

</FONT><B><FONT FACE="Courier New" SIZE=2 COLOR="#0000ff">0</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#ff0000">111</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#0000ff">00000<BR>
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#ff0000">11111</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#0000ff">0000<BR>
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#ff0000">111111</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#0000ff">000<BR>
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#ff0000">1111111</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#0000ff">00<BR>
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#ff0000">11111111</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#0000ff">0<BR>
</FONT><FONT FACE="Courier New" SIZE=2 COLOR="#ff0000">111111111<BR>
</B></FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY"></P>

<P ALIGN="JUSTIFY">Lo que har&iacute;amos ser&iacute;a leer y copiar a pantalla s&oacute;lo aquellas zonas que fueran </FONT><B><FONT FACE="Arial" SIZE=2 COLOR="#ff0000">1</B></FONT><FONT FACE="Arial" SIZE=2>. De esta forma, se logra representar una imagen discontinua en pantalla pues la porci&oacute;n que tenga el color </FONT><B><FONT FACE="Arial" SIZE=2 COLOR="#0000ff">0</B></FONT><FONT FACE="Arial" SIZE=2>, no se dibujar&iacute;a (prevaleciendo lo que hubiera debajo). Podr&iacute;amos imaginarnos que el color rojo representa una textura de tierra. Si debajo hubiera un &quot;tile&quot; de oc&eacute;ano, al aplicar esta t&eacute;cnica, el gr&aacute;fico resultante ser&iacute;a una costa. Otro ejemplo ser&iacute;a suponer un &quot;tile&quot; que simule un &aacute;rbol. Este no tiene que ocupar todo su espacio con datos distintos a 0, sino que se supone que se dibujar&aacute; sobre una base ocupando una peque&ntilde;a porci&oacute;n de la misma. Lo &uacute;nico que tenemos que hacer es dibujar un &aacute;rbol no muy grande y poner a valor 0 todas aquellas partes que quedan a su alrededor para que no se pinten en pantalla. La mejor idea es construir los &quot;tiles&quot; sobre una plantilla de color igual al que tengamos seleccionado como color invisible. Ver figura del &aacute;rbol:</P>
<P ALIGN="JUSTIFY"></P>
<center><img src="jpg/tiles05.jpg"></center>
<FONT SIZE=1 FACE=ARIAL><CENTER>Ejemplo de dibujado de un árbol.</CENTER></FONT>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">A&ntilde;adir, para finalizar este apartado, que como los &quot;tiles&quot; base siempre tiene todo con valores distintos de 0 (no tienen porciones de color invisible) al dibujarse en pantalla "machacar&aacute;n" a lo que hab&iacute;a antes.</P>

</FONT><h4><FONT FACE="Arial">&quot;tiles&quot; que se construyen en tiempo de ejecuci&oacute;n.
</h4></FONT><FONT FACE="Arial" SIZE=2>
<P ALIGN="JUSTIFY">Anteriormente se mencion&oacute; el hecho de que existen &quot;tiles&quot;, pertenecientes al set de forma, que se construyen en tiempo de ejecuci&oacute;n. Esto es as&iacute; porque hay un tipo especial de tile de forma que se encarga de simular el paso de una base o terreno a otro. Como existen un total de 7 terrenos base a representar y 12 son los tipos distintos de &quot;tiles&quot; dedicados a simular el paso de una zona a otra, necesitar&iacute;amos un total de 12 x 7 = 84 &quot;tiles&quot;. Para solucionar el problema lo que se hace es construir esos &quot;tiles&quot; por medio de otros llamados &quot;tiles&quot; molde en conjunci&oacute;n con los propios &quot;tiles&quot; de base. Un tile de molde es aquel que est&aacute; compuesto por 2 colores. Un color 0, como color invisible, y un color distinto de 0 para simbolizar que en esa zona ha de ir la textura del &quot;tile&quot; de base sobre el que se debe de aplicar el molde. El proceso de construcci&oacute;n de los &quot;tiles&quot; de transici&oacute;n es bien sencillo. Debemos de llevar todos aquellos pixels que representan color invisible en el &quot;tile&quot; de molde, al &quot;tile&quot; de base. Para ello, comenzamos a recorrer el &quot;tile&quot; de molde. Si el color le&iacute;do es el color invisible, lo ponemos encima del &quot;tile&quot; de base para el que queremos construir la transici&oacute;n. En cualquier otro caso, no copiamos nada sobre el &quot;tile&quot; de base y continuamos con el proceso de construcci&oacute;n hasta que acabemos de recorrer todo el &quot;tile&quot; de molde. Es decir:</P>

</FONT><FONT FACE="Courier New" SIZE=2><B>0000000</B><BR>
<B>0</B>1<B>00</B>11<B>0</B><BR>
111<B>00</B>11<BR>
1111111<BR>
1111111<BR>
1111111<BR>
</FONT><FONT FACE="Courier New" SIZE=1 COLOR="#ff0000">
Tile de molde.
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=2>
1234112<BR>
1245235<BR>
2189432<BR>
2182912<BR>
1292394<BR>
2343464<BR>
</FONT><FONT FACE="Courier New" SIZE=1 COLOR="#ff0000">
Tile base [suponiendo que sea de 9 colores distintos]
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">El tile que queda al montar un tile sobre otro es el siguiente:</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Courier New" SIZE=2><B>0000000</B><BR>
<B>0</B>2<B>00</B>23<B>0</B><BR>
218<B>00</B>32<BR>
2182912<BR>
1292394<BR>
2343464<BR>
</FONT><FONT FACE="Courier New" SIZE=1 COLOR="#ff0000">
Este es el tile resultado
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Como puede apreciarse, el tile que hemos construido no es m&aacute;s que el tile de base pero poniendo a 0 las zonas que est&aacute;n a 0 en el tile de molde. Esta t&eacute;cnica tan sencilla nos permite ahorrarnos un buen mont&oacute;n de &quot;tiles&quot;. L&oacute;gicamente, el tile resultante "no existe en ning&uacute;n sitio" (no est&aacute; almacenado en ning&uacute;n fichero gr&aacute;fico), sino que se crea siempre que se necesita dibujar en pantalla. </P>
<P ALIGN="JUSTIFY"></P>
</FONT><h4><FONT FACE="Arial">Anexos
</h4></FONT><FONT FACE="Arial" SIZE=2>
<P ALIGN="JUSTIFY">Hasta aqu&iacute;, hemos explicado la base sobre la que poder construir el engine de &quot;tiles&quot; en 2D. Ahora, vamos a ver otros aspectos que pueden ayudarnos a la hora de plantear la construcci&oacute;n del engine basado en &quot;tiles&quot;. Haremos referencia (muy por encima, porque el cometido de este art&iacute;culo ya se ha cubierto) a aspectos del &quot;Maptool&quot; que, sin formar parte directa del engine, s&iacute; que le dan un toque m&aacute;s profesional e interesante. Tambi&eacute;n comentaremos posibles mejoras para que nadie se pierda a la hora de implementar su propio sistema basado en &quot;tiles 2D&quot;.</P>

<table align="left"><td><img src="jpg/tiles06.jpg"></td></table><B><P>El mini - mapa.</P>
</B>
<P ALIGN="JUSTIFY">Una de las mayores comodidades del editor es el mini - mapa. Su implementaci&oacute;n no reviste mayores problemas. El mini - mapa ocupa una dimensiones de 64x64 pixels en pantalla. Cada pixel de pantalla representa una posici&oacute;n del mapa que estamos editando, o lo que es lo mismo, un tile de 32x32 pixels. Como hay tres &quot;tiles&quot; que pueden dibujarse en una &uacute;nica posici&oacute;n del mapa, lo que se hace es establecer unas prioridades de identificaci&oacute;n. Cada tile que se dibuja en el mini - mapa tiene asignado un color, salvo los &quot;tiles&quot; que pertenecen al set de &quot;tiles&quot; objetos que tienen todos como color asignado el color rojo. </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Por tanto, el m&eacute;todo a la hora de representar el mini mapa es el de dibujar el tile de mayor prioridad representado, precisamente, la zona del mapa en donde se encuentra. La m&aacute;xima prioridad de dibujado en el mini mapa es inversa a la del mapa de edici&oacute;n, es decir, si hay tile objeto se dibuja ese tile y si no se mira si hay tile forma, si hay tile forma se dibuja ese tile. De nuevo, si no hay tile forma, entonces seguro que hay tile base y es ese tile el que se identifica en el mini - mapa.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">El mini - mapa se actualiza s&oacute;lo en la zona que ha sido actualizada en el mapa de edici&oacute;n, es decir, se actualiza cuando hacemos una modificaci&oacute;n.</P>
<P ALIGN="JUSTIFY"></P>
<B><P>Implementaci&oacute;n del zoom en el mapa global.</P>
</FONT><FONT FACE="Arial" SIZE=4>
</B></FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Una de las opciones m&aacute;s interesantes del &quot;Maptool&quot; es la referente al mapa global y la posibilidad de hacer zoom tanto para acercarnos a ellos como para alejarnos. Las prestaciones por defecto del mapa global permiten divisar un mapa con 10 &quot;tiles&quot; a lo ancho y 6 a lo alto frente a los 7 y 4 que permite el mapa de edici&oacute;n. Esto ya supone una gran ventaja pues podemos ver m&aacute;s terreno real. Pero lo que de verdad puede ser m&aacute;s interesante a la hora de ir viendo el trabajo que vamos haciendo es ver el mapa mediante sucesivos zoom. Podemos acercarnos al terreno y ver los &quot;tiles&quot; m&aacute;s grandes o podemos alejarnos y ver los &quot;tiles&quot; m&aacute;s peque&ntilde;os. Con &eacute;ste modo de zoom, podemos llegar a ver hasta 20 &quot;tiles&quot; horizontales y 18 verticales es decir, en pantalla estar&iacute;amos viendo un total de 20x8=160 &quot;tiles&quot; a la vez, frente a los 7x4=28 &quot;tiles&quot; que vemos en el mapa de edici&oacute;n normal.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Una de las primeras soluciones que pens&eacute; para llevar a cabo este proceso fue la de disponer de peque&ntilde;os &quot;tiles&quot; acordes a lo que deber&iacute;a ser un zoom, tanto de acercamiento o alejamiento. Esta soluci&oacute;n, fue r&aacute;pidamente desechada porque ser&iacute;a muy ineficiente (ser&iacute;a una salvajada). Estaba claro que esa no pod&iacute;a ser la soluci&oacute;n as&iacute; que se ten&iacute;a que implementar por software, alg&uacute;n tipo de escalado para reducir los &quot;tiles&quot;. Al final, se decidi&oacute; implementar el siguiente m&eacute;todo: Cada vez que nos alejemos se ir&aacute;n repitiendo pixels del tile que estamos dibujando, mientras nos acerquemos, se ir&aacute;n desechando pixels del &quot;tile&quot; que estamos dibujando.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">As&iacute; pues, cada vez que nos alejamos m&aacute;s del mapa se va examinando cada menos tiempo un contador que se inicializa a 0 y que, llegado a un determinado valor de tope, indica que el pixel que se ha puesto en pantalla se ha de repetir, o no, en la siguiente operaci&oacute;n. As&iacute;, si nos acercamos 2 casillas, y los &quot;tiles&quot; son de 32x32, el contador tendr&aacute; que llegar al tope 32/2 -1, es decir, 15. Cuando llegue a 15, no se aumentar&aacute; el puntero que recorre el buffer en d&oacute;nde se encuentra la imagen o &quot;tile&quot; que estamos copiando (recordemos que, antes de mostrar todo en pantalla, se construye en una pantalla virtual para, posteriormente, volcarlo a memoria de v&iacute;deo) sino que se mantendr&aacute; obligando a que la siguiente iteraci&oacute;n dibuje lo mismo. Seguidamente, el contador se inicializar&aacute; a 0. Es f&aacute;cil deducir que a medida que nos acerquemos m&aacute;s el tope disminuir&aacute; se tender&aacute; a repetir m&aacute;s veces partes del dibujo, es decir, la f&oacute;rmula ser&aacute; (32/aumento – 1). El contador se utilizar&aacute; tanto para dibujar columnas como filas.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">En el caso de estar alej&aacute;ndonos a pantalla todo ser&aacute; igual salvo que, en lugar de no aumentar el puntero que recorre el buffer en donde est&aacute; el tile que debemos de dibujar en pantalla, lo que haremos ser&aacute; aumentarlo dos veces, esto provocar&aacute; que parte del tile no se dibuje. A medida que m&aacute;s nos acerquemos, el contador indicar&aacute; que esa operaci&oacute;n ha de hacerse m&aacute;s a menudo. </P>
<P ALIGN="JUSTIFY"></P>
<B><P>Rutina de relleno de la zona editada.</P>
</B>
<P ALIGN="JUSTIFY">Esta rutina se encarga de rellenar la parte de edici&oacute;n que estamos viendo de un solo tile, el que est&eacute; seleccionado. Para ello, lo &uacute;nico que se hace es actualizar el array con los datos sobre el tile y, despu&eacute;s, actualizar la pantalla dibujando s&oacute;lo la zona que estamos viendo seg&uacute;n las t&eacute;cnicas de pantalla virtual vistas anteriormente.</P>
<P ALIGN="JUSTIFY"></P>
<B><P>Rutina de la implementaci&oacute;n de una rejilla.</P>
</B>
<P ALIGN="JUSTIFY">La opci&oacute;n de rejilla lo &uacute;nico que hace es dibujar en pantalla los contornos de cada uno de los &quot;tiles&quot; de color negro. No es ning&uacute;n tema complicado pues lo &uacute;nico que se hace es trazar l&iacute;neas verticales y horizontales respetando las dimensiones de cada tile, es decir, las dimensiones de 32x32.</P>

<B><P>Animaci&oacute;n de los &quot;tiles&quot;.</P>
</B><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Uno de los efecto que m&aacute;s pueden llamar la atenci&oacute;n, es el referente al tema de la animaci&oacute;n del agua. Para realizar este efecto, lo que se hace es utilizar una funci&oacute;n de rotaci&oacute;n de paleta. Para ello, la podemos llamar utilizando una rutina que se aloje en el vector de interrupciones y que el time la vaya llamando a intervalos de tiempo est&aacute;ndar. Si estamos programando bajo Windows, bastar&iacute;a con utilizar temporizadores. La rotaci&oacute;n de la paleta produce excelentes resultados y dan mucha vivacidad al escenario. </P>
<P ALIGN="JUSTIFY"></P>
<B><P>¿Arrays o listas din&aacute;micas?.</P>
</B><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Como se cit&oacute; al comienzo del art&iacute;culo, esta aplicaci&oacute;n tiene ya unos a&ntilde;itos y los cambios que se han ido sucediendo en la misma han estado supeditados al uso personal. En el caso de que queramos construir una aplicaci&oacute;n flexible o un juego que utilice niveles de distinto tama&ntilde;o, deberemos de utilizar, obligatoriamente, listas din&aacute;micas; m&aacute;s concretamente, listas de listas. Las listas van a permitirnos ocupar la memoria que necesitemos en cada momento con todas las ventajas que ello comporta. Al utilizar arrays, estamos predefiniendo el tama&ntilde;o de nuestros niveles o pantallas por lo que esto se torna muy ineficaz. La &uacute;nica ventaja que aportan los arrays frente a las listas (a parte de su mayor facilidad de implementaci&oacute;n), es que son de m&aacute;s r&aacute;pido acceso pues los datos se almacenan en posiciones consecutivas de memoria. Este art&iacute;culo no est&aacute; destinado a comentar las estructuras de datos din&aacute;micas. Simplemente, realizamos una menci&oacute;n a la posibilidad de implementar el engine con estructuras de datos mucho m&aacute;s flexibles y que, de hecho, deber&iacute;an de ser utilizadas..</P>
<P ALIGN="JUSTIFY"></P>
<B><P>Una peque&ntilde;a menci&oacute;n a las pantallas virtuales o buffers.</P>
</B><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Las pantallas virtuales sirven para construir la imagen que debemos de mostrar en pantalla. Por ejemplo, si el usuario se ha movido de un lado a otro de la pantalla, lo que se hace es construir en un buffer, de un tama&ntilde;o igual al &aacute;rea de pantalla en donde se muestra el mapa, lo que se deber&iacute;a de mostrar despu&eacute;s del movimiento. Una vez que se ha construido todo en este buffer, se procede a volcarlo, por medio de alguna rutina r&aacute;pida, a pantalla. Este m&eacute;todo permite construir im&aacute;genes compuestas de muy distintos tipos de objetos de una forma muy elegante y, sobre todo, &oacute;ptima de cara al usuario. En el &quot;Maptool&quot; lo que se hace es construir todo el mapa de edici&oacute;n en una pantalla virtual y luego, mediante la rutina en ensamblador r&aacute;pida, dibujar o volcar todo r&aacute;pidamente. </P>
<P ALIGN="JUSTIFY"></P>
<B><P ALIGN="JUSTIFY">Algunas t&eacute;cnicas m&aacute;s a tener en cuenta</P>
</B><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">A&uacute;n hay algunos cuantos aspectos que podr&iacute;amos considerar en la construcci&oacute;n de un engine basado en &quot;tiles&quot; (que en el &quot;Maptool&quot; no se utilizan). Ah&iacute; van:</P>
<P ALIGN="JUSTIFY"></P>

<UL>
<B><P ALIGN="JUSTIFY"><LI>Utilizaci&oacute;n de una cuarta capa de tiles.</LI></P></UL>
<DIR>

</B><P ALIGN="JUSTIFY">Uno de los aspectos que podr&iacute;amos considerar, podr&iacute;a ser el de dotar al engine de una cuarta capa. Esta capa, ser&iacute;a la que ir&iacute;a por encima de todas las dem&aacute;s (incluso por encima de la capa que cubre los aspectos de objeto) y que cubrir&iacute;a, por as&iacute; decirlo, lo que est&aacute; en el aire. Imagin&eacute;monos la siguiente situaci&oacute;n. Nuestro personaje va caminando y se encuentra con una casa con la puerta abierta (obviamente, deber&iacute;amos de construir m&uacute;ltiples tiles que sirvan para crear el contorno de la casa, sus interiores, etc). Cuando el personaje est&aacute; fuera de la casa, lo que ve no es m&aacute;s que el tejado de la misma y las paredes (dependiendo, siempre, de la pericia del grafista del grupo). Cuando entre en la casa, ¿qu&eacute; pasar&aacute;?. Tenemos dos opciones. Una ser&iacute;a cargar en memoria un mini-escenario, en el que se mostrar&iacute;a la casa por dentro. Otra, ser&iacute;a no dibujar el tejado de la casa y ver a nuestro personaje caminando por su interior. Esto &uacute;ltimo, es lo que nos brindar&iacute;a la utilizaci&oacute;n de una cuarta capa de tiles. Como veis, resulta sumamente interesante hacer algo as&iacute;. De hecho, es lo que se utiliza en la mayor&iacute;a de los juego. El coste de implementar algo como esto es muy bajo pues tan s&oacute;lo deberemos de comprobar si el personaje est&aacute; sobre una casilla que mantiene una casa. Si est&aacute;, a la hora de dibujarla desecharemos el pintar los &quot;tiles&quot; que forman el tejado de la misma (los que se encuentran en la cuarta capa de &quot;tiles&quot;) con lo que siempre veremos a nuestro personaje andando por su interior. Cuando salgamos de la casa, s&iacute; que pintaremos el tejado del recinto, dej&aacute;ndonos sin ver lo que hay en su interior.</P>
<P ALIGN="JUSTIFY"></P></DIR>


<UL>
<B><P ALIGN="JUSTIFY"><LI>Area de visibilidad del escenario.</LI></P></UL>
<DIR>

</B><P ALIGN="JUSTIFY">Otra de las t&eacute;cnicas que pueden resultar muy interesantes, es la referida a la implementaci&oacute;n de un sistema que calcule el &aacute;rea de visibilidad del personaje. Como siempre, el problema se divide en un proceso de c&aacute;lculo interno y otro externo. En el interno, debemos de determinar el c&aacute;lculo de las casillas que el persona puede ver. As&iacute;, por ejemplo, si el personaje tiene una visibilidad de 5 significar&aacute; que podr&aacute; ver en un radio de 5 casillas (5 casillas por cada uno de los posibles lados del personaje). La representaci&oacute;n externa hace referencia a la implementaci&oacute;n gr&aacute;fica del problema. Para simular el &aacute;rea de visibilidad, podemos hacer que aquellas casillas que queden fuera del &aacute;rea del visibilidad del personaje se dibujen con alg&uacute;n tipo de niebla (dibujamos los &quot;tiles&quot; y, encima, un &quot;tile&quot; que tenga puntos aleatorios de negro y color invisible) o que s&oacute;lo dibuje el &quot;tile&quot; de base sin dejarnos saber si hay un r&iacute;o, un personaje, un enemigo, un objeto, etc, encima del mismo.</P>
<P ALIGN="JUSTIFY"></P></DIR>

</FONT><B><FONT FACE="Arial"><P ALIGN="JUSTIFY">En conclusi&oacute;n.</P>
</B></FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">En este art&iacute;culo hemos visto c&oacute;mo poder implementar engines basados en el concepto de &quot;tile 2D&quot;. Aunque este tipo de &quot;tile&quot; no dota de profundidad a nuestros escenarios, puede sac&aacute;rsele mucho provecho si las estructuras que se construyen encima del mismo s&iacute; tienen car&aacute;cter tridimensional (llegando a emular lo que puede ofrecer un engine basado en &quot;tiles&quot; isom&eacute;tricos).</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">En definitiva, el uso de esta t&eacute;cnica reporta importantes beneficios de cara al desarrollo de juegos de estrategia que tengan que representar grandes escenarios. Tambi&eacute;n resulta muy &uacute;til para juegos de aventuras o rol en los que el protagonista deba de caminar por mampeados grandes. Adem&aacute;s, otra de las virtudes del uso de &quot;tiles&quot; es que no son complicados de manejar. Ahora bien, resulta ineludible que el grupo de desarrollo se construya sus propias herramientas para el dise&ntilde;o de niveles.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Antes de finalizar el art&iacute;culo, comentar que aqu&iacute; se han expuesto las ideas b&aacute;sicas sobre este tipo de t&eacute;cnica y que, con ellas, ya es posible que todo aquel que tenga unos conocimientos m&iacute;nimos de programaci&oacute;n gr&aacute;fica (en cualquier sistema) pueda hacer su juego o editor basado en &quot;tiles&quot;. Comentar a esto &uacute;ltimo, que es recomendable que trabaj&eacute;is siempre que pod&aacute;is, con listas din&aacute;micas y no con arrays pues, de lo contrario, vuestros escenarios no podr&aacute;n crecer en tama&ntilde;o y siempre estar&aacute;n supeditados a un tope.</P></FONT><BR><BR>

<hr width=60%>
<CENTER>
<FONT size=2 color="#cc0000" face="Arial">
<b>No olvides llevarte el </b><A HREF="zip/maptool.zip"><B>MapTool</B></a>
</CENTER>
<hr width=70%>
<br>

<P ALIGN="RIGHT"><FONT COLOR="#0080C0" size=2 face="arial"><B>Ú</B></font><FONT color="#000000" size=1 face="arial">LTIMA REVISIÓN EN</FONT> <FONT color="#CC0000" size=2 face="arial"><B>ABRIL</B></FONT><FONT color="#000000" size=1 face="arial"> DE </FONT><FONT color="#CC0000" size=2 face="arial"><B>1999</B></FONT>











<br>

<hr>

<center><TABLE CELLPADDING=2 WIDTH="100%">



<TD  WIDTH="50%" VALIGN="TOP" align="left">



<TABLE BORDER=1 WIDTH="100%" HEIGHT="*" BGCOLOR="#CC0000" cellspacing=0 CELLPADDING=2>

<TD>

<TABLE BORDER=0 WIDTH="100%"  HEIGHT="*" BGCOLOR="#FDEDBD" cellspacing=0 CELLPADDING=2>

<TR>

<TD>

<DIV align="CENTER">

<FONT SIZE=2>

<A HREF="pjuegos.htm"><font FACE="ARIAL"><B>[Desarrollo de Videojuegos]</B></font></a> <hR>

<A HREF="epj.htm"><font FACE="ARIAL"><B>[Entornos 2D]</B></font></a> <br>

</DIV>

</TD>

</TR>

</TABLE>

</TD>

</TABLE>

</TD>

</TABLE>





<br>

<HR>







<CENTER><TABLE BORDER=0 COLS=1 WIDTH="100%" >

<TR>

<TD>

<TABLE BORDER=0 COLS=1 WIDTH="50%" BGCOLOR="#F1E08D" >

<TR>

<TD>

<CENTER><B><FONT FACE="Arial,Helvetica"><FONT COLOR="#000000">DESARROLLO DE VIDEOJUEGOS</FONT></FONT></B></CENTER>

</TD>

</TR>

</TABLE>



<CENTER><TABLE BORDER=0 COLS=1 WIDTH="100%" BGCOLOR="#0080C0" >

<TR>

<TD BGCOLOR="#0080C0"><FONT COLOR="#0080C0">a</FONT></TD>

</TR>

</TABLE></CENTER>



<DIV ALIGN=right><TABLE BORDER=0 COLS=1 WIDTH="50%" BGCOLOR="#F1E08D" >

<TR>

<TD>

<CENTER><B><FONT FACE="Arial,Helvetica">MACEDO<FONT COLOR="#CC0000">N</FONT>IA Magazine</FONT></B></CENTER>

</TD>

</TR>

</TABLE></DIV>

</TD>

</TR>

</TABLE></CENTER>

</HTML>



